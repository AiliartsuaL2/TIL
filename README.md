# study_java_effectiveJava
EffectiveJava 개인 공부 필기 + 인프런 백기선 EffectiveJava 라이브코딩


<details>
  <summary><b>2장 객체 생성과 파괴</b></summary>
  <details>
     <summary><b>Item1 생성자 대신 정적 팩터리 메서드를 고려하라</b></summary>
    
     >> 평범한 경우에는 생성자를 사용하고, 정적 팩터리가 유리한 경우에는 생성자만 쓰지말고 정적 팩터리 메서드도 고려를 해봐라
- 클라이언트가 클래스의 인스턴스를 방법
    - 전통적인 수단 : public 생성자
    - 정적 팩터리 메서드 (static factory method) : 해당 클래스의 인스턴스를 반환하는 단순한 정적 메서드 (디자인 패턴의 팩터리 메서드와 다름)
        - 정적 팩터리 메서드 : 객체의 생성 역할을 하는 클래스 메서드 (생성자를 통해 객체를 생성하는게 아닌, 메서드를 통해 객체를 생성해주는 메서드)
        - 클래스는 클라이언트에 public 생성자 대신 정적 팩터리 메서드를 제공,
            - 장점 : 
                - 1. 이름을 가질 수 있다.
                    - 생성자는 이름을 바꿀 수 없고, 생성자를 다르게 일부 필드만 변경하려면 파라미터의 순서를 바꾸어 선언하는등의 번거로움이 있음..
                    - 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명 못함.. (메서드 명으로 해당 생성자가 무엇을 의미하는지 명확한 의미전달 가능)
                - 2. 호출 될 때마다 인스턴스를 새로 생성하지 않아도 된다.
                    - 생성자는 기본적으로 매번 새로운 인스턴스를 만든다. 
                    - 인스턴스의 통제가 필요한 경우가 있는데, 생성자가 있으면 통제가 불가능함.
                    - 불변 클래스는 인스턴스를 미리 만들어 놓는 등 불필요한 객체 생성을 피할 수 있다. >> 생성 비용이 큰 객체가 자주 요청되는 상황시 성능을 올려준다.
                    - 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어떤 인스턴스를 살아 있게 할 지 철저히 통제 가능 >> 인스턴스 통제 클래스
                        - 인스턴스 통제 클래스는 클래스를 싱글턴으로 만들수도, 인스턴스화 불가로 만들 수 있다. 
                        - 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장 할 수 있다.
                        - 인스턴스 통제는 플라이웨이트 패턴의 근간이 된다.
                        - 열거 타입 인스턴스가 하나만 만들어짐을 보장
                        - 플라이 웨이트 패턴 (자주 사용하는 값들을 미리 캐싱해서 넣어두고, 꺼내서 쓰는 패턴,,) 과 유사함
                - 3. 반환 타입의 하위 타입 객체를 반환 할 수 있는 능력이 있다.
                    - 반환할 객체의 클래스를 자유롭게 선택 할 수 있다. >> 큰 유연성 보장. ,, API 구현 시, 작게 유지 할 수 있다.
                    - 인터페이스 타입을 사용 가능 (정적 팩터리 메서드 사용시 리턴 타입에 인터페이스를 두고, 실제 리턴은 해당 인터페이스의 구현체로 해줌)
                    - 자바 8 이후부터는 인터페이스에 정적 메서드를 선언 가능, 이를 통해 컬렉션 프레임워크에 핵심 인터페이스들에 수정 불가나 동기화 등의 기능을 붙인 구현체를 java.util.Collections를 통해 얻도록 했음. 
                        - 해당 인터페이스의 정적 팩터리 메서드를 호출하여 객체를 생성하는 클라이언트 입장에서 선언된 객체의 타입은 인터페이스가 된다! (이렇게 하면 API를 만들 때 구현 클래스를 공개하지 않고도 그 객체를 반환 할 수 있어 API를 작게 유지 가능) >> 인터페이스 기반 프레임워크를 만드는 핵심 기술
                        - 클래스에서는 메서드에 접근지정자를 붙이지 않으면 package 레벨의 접근지정자가 되고, 인터페이스에서는 public 레벨의 접근 지정자가 된다.
                - 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.
                    - 3번의 내용과 같이, 해당 타입의 리턴하는 타입의 하위타입인 경우 리턴의 구현체로 사용 가능하다.
                    - 3번 내용과 같이 클라이언트는 반환 타입의 존재를 모르고 알 필요도 없다. 그냥 해당 객체의 하위 클래스이기만 하면된다. 
                        - EnumSet 클래스는 public 생성자 없이 정적 팩터리만 제공하는데, OpenJDK에서는 원소의 수에 따라 두가지 하위 클래스 중 하나의 인스턴스를 반환한다. 
                            - 원소가 64개 이하면 원소들을 long 변수 하나로 관리하는 RegularEnumSet의 인스턴스를
                            - 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.
                - 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
                    - ServiceLoader를 통해서 해당 인터페이스에 해당하는 구현체의 객체를 받아와 메서드를 실행 할 수 있음.
                    - 이렇게 하면 구현체에 의존적이지 않고 인터페이스에 의존하게 됨 >> 많은 유연성 제공
            - 단점
                - 1. 상속을 하려면 private나 protected 생성자가 필요한데, 정적 팩터리 메서드를 사용하려면 생성자를 private하게 선언하고 정적 팩터리 메서드를 선언하기 때문에 상속이 불가능하다.
                    - 상속보다 컴포지션()을 하도록 유도하면서 불편타입으로 만들려면 이 제약을 지켜야한다는 점에서 장점으로 받아들일 수 있다.
                - 2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다
                    - javadoc을 사용하면 생성자는 API가 칸이 특별하게 생성되서 나오는 반면, 정적 팩토리 메서드를 사용하면 다른 메서드들과 엮이기 때문에 클라이언트가(해당 API를 사용하는 사용자) 찾기가 어려움.
                        - 네이밍 규칙을 이용하여 해결한다 (javadoc에 스태틱 메서드 탭이 있으니 거기서 그래도 찾기 쉬우라고)
                            - from : 매개변수 1개를 받아서 인스턴스를 리턴하는 경우
                            - of,valueOf : 매개변수 여러개를 받아서 인스턴스를 만들어 리턴하는 경우 
                            - valueOf : of, from보다 더 자세하게 매개변수를 받는다.
                            - instance, getInstance : 미리 만들어져있는 인스턴스를 가져오는 경우 (같은 인스턴스임을 보장하지는 않음!)
                            - create , newInstance : 매번 새로운 인스턴스를 생성해 반환하는 경우.(다른 인스턴스를 보장)
                            - getType : getInstance 에서 인스턴스를 가져오는데 다른 클래스에서 팩터리 메서드를 정의 할 때 사용
                            - newType : newInstance에서 인스턴스를 가져오는데 다른 클래스에서 팩터리 메서드를 정의 할 때 사용
                                - BuffredReader br = Files.newBufferedReader(path);
                            - type : getType과 newType의 간결한 버전
                                - List<Product> productLitst = Collections.list(legacyProductList);
                        - 문서화(javadoc)를 통해 메서드를 설명한다. 
                            - javadoc 규약
                                - @param : 매개변수에 대한 설명
                                - @return : 반환값에 대한 설명
                                - @throws : 던지는 예외에 대한 설명
                                - @see : 외부 링크 또는 텍스트를 표시,,다른 필드나 메소드에 대한 모든 참조 링크를 나타내는 경우 사용
                                - /** 주석을 통해 설명해놓고 @see를 사용, 참조함을 알려주는건 클래스명#메서드명 (자기 자신일 경우 #메서드명)  
                            - javadoc 실행 방법
                                - tools > generated javadoc 클릭
                                - 한글 깨짐 방지를 위해 Other command line arguments에 
                                    - encoding UTF-8 charset UTF-8 docencoding UTF-8 > OK
                                    - open generated documentation in browser 체크하면 생성 후 자동으로 열림,, 
                                        - 체크 안해놨으면 해당 파일 경로의 index.html 열기.
  </details>
  
  <details>
  <summary><b>Item2 생성자에 매개변수가 많다면 빌더를 고려하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item3 private 생성자나 열거 타입으로 싱글턴임을 보증하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item4 인스턴스화를 막으려거든 private 생성자를 사용하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item6 불필요한 객체 생성을 피하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item7 다 쓴 객체 참조를 해제하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item8 finalizer와 cleaner 사용을 피하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item9 try-finally보다는 try-with-resources를 사용하라</b></summary>
  
  </details>
  
</details> 

<details>
  <summary><b>3장 모든 객체의 공통 메서드</b></summary>
  
</details>
