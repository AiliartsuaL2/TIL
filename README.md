# study_java_effectiveJava
EffectiveJava 개인 공부 필기 + 인프런 백기선 EffectiveJava 라이브코딩


<details>
  <summary><b>2장 객체 생성과 파괴</b></summary>
  <details>
     <summary><b>Item1 생성자 대신 정적 팩터리 메서드를 고려하라</b></summary>
    
     >> 평범한 경우에는 생성자를 사용하고, 정적 팩터리가 유리한 경우에는 생성자만 쓰지말고 정적 팩터리 메서드도 고려를 해봐라
- 클라이언트가 클래스의 인스턴스를 방법
    - 전통적인 수단 : public 생성자
    - 정적 팩터리 메서드 (static factory method) : 해당 클래스의 인스턴스를 반환하는 단순한 정적 메서드 (디자인 패턴의 팩터리 메서드와 다름)
        - 정적 팩터리 메서드 : 객체의 생성 역할을 하는 클래스 메서드 (생성자를 통해 객체를 생성하는게 아닌, 메서드를 통해 객체를 생성해주는 메서드)
        - 클래스는 클라이언트에 public 생성자 대신 정적 팩터리 메서드를 제공,
            - 장점 : 
                - 1. 이름을 가질 수 있다.
                    - 생성자는 이름을 바꿀 수 없고, 생성자를 다르게 일부 필드만 변경하려면 파라미터의 순서를 바꾸어 선언하는등의 번거로움이 있음..
                    - 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명 못함.. (메서드 명으로 해당 생성자가 무엇을 의미하는지 명확한 의미전달 가능)
                - 2. 호출 될 때마다 인스턴스를 새로 생성하지 않아도 된다.
                    - 생성자는 기본적으로 매번 새로운 인스턴스를 만든다. 
                    - 인스턴스의 통제가 필요한 경우가 있는데, 생성자가 있으면 통제가 불가능함.
                    - 불변 클래스는 인스턴스를 미리 만들어 놓는 등 불필요한 객체 생성을 피할 수 있다. >> 생성 비용이 큰 객체가 자주 요청되는 상황시 성능을 올려준다.
                    - 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어떤 인스턴스를 살아 있게 할 지 철저히 통제 가능 >> 인스턴스 통제 클래스
                        - 인스턴스 통제 클래스는 클래스를 싱글턴으로 만들수도, 인스턴스화 불가로 만들 수 있다. 
                        - 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장 할 수 있다.
                        - 인스턴스 통제는 플라이웨이트 패턴의 근간이 된다.
                        - 열거 타입 인스턴스가 하나만 만들어짐을 보장
                        - 플라이 웨이트 패턴 (자주 사용하는 값들을 미리 캐싱해서 넣어두고, 꺼내서 쓰는 패턴,,) 과 유사함
                - 3. 반환 타입의 하위 타입 객체를 반환 할 수 있는 능력이 있다.
                    - 반환할 객체의 클래스를 자유롭게 선택 할 수 있다. >> 큰 유연성 보장. ,, API 구현 시, 작게 유지 할 수 있다.
                    - 인터페이스 타입을 사용 가능 (정적 팩터리 메서드 사용시 리턴 타입에 인터페이스를 두고, 실제 리턴은 해당 인터페이스의 구현체로 해줌)
                    - 자바 8 이후부터는 인터페이스에 정적 메서드를 선언 가능, 이를 통해 컬렉션 프레임워크에 핵심 인터페이스들에 수정 불가나 동기화 등의 기능을 붙인 구현체를 java.util.Collections를 통해 얻도록 했음. 
                        - 해당 인터페이스의 정적 팩터리 메서드를 호출하여 객체를 생성하는 클라이언트 입장에서 선언된 객체의 타입은 인터페이스가 된다! (이렇게 하면 API를 만들 때 구현 클래스를 공개하지 않고도 그 객체를 반환 할 수 있어 API를 작게 유지 가능) >> 인터페이스 기반 프레임워크를 만드는 핵심 기술
                        - 클래스에서는 메서드에 접근지정자를 붙이지 않으면 package 레벨의 접근지정자가 되고, 인터페이스에서는 public 레벨의 접근 지정자가 된다.
                - 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환 할 수 있다.
                    - 3번의 내용과 같이, 해당 타입의 리턴하는 타입의 하위타입인 경우 리턴의 구현체로 사용 가능하다.
                    - 3번 내용과 같이 클라이언트는 반환 타입의 존재를 모르고 알 필요도 없다. 그냥 해당 객체의 하위 클래스이기만 하면된다. 
                        - EnumSet 클래스는 public 생성자 없이 정적 팩터리만 제공하는데, OpenJDK에서는 원소의 수에 따라 두가지 하위 클래스 중 하나의 인스턴스를 반환한다. 
                            - 원소가 64개 이하면 원소들을 long 변수 하나로 관리하는 RegularEnumSet의 인스턴스를
                            - 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 반환한다.
                - 5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
                    - ServiceLoader를 통해서 해당 인터페이스에 해당하는 구현체의 객체를 받아와 메서드를 실행 할 수 있음.
                    - 이렇게 하면 구현체에 의존적이지 않고 인터페이스에 의존하게 됨 >> 많은 유연성 제공
            - 단점
                - 1. 상속을 하려면 private나 protected 생성자가 필요한데, 정적 팩터리 메서드를 사용하려면 생성자를 private하게 선언하고 정적 팩터리 메서드를 선언하기 때문에 상속이 불가능하다.
                    - 상속보다 컴포지션()을 하도록 유도하면서 불편타입으로 만들려면 이 제약을 지켜야한다는 점에서 장점으로 받아들일 수 있다.
                - 2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다
                    - javadoc을 사용하면 생성자는 API가 칸이 특별하게 생성되서 나오는 반면, 정적 팩토리 메서드를 사용하면 다른 메서드들과 엮이기 때문에 클라이언트가(해당 API를 사용하는 사용자) 찾기가 어려움.
                        - 네이밍 규칙을 이용하여 해결한다 (javadoc에 스태틱 메서드 탭이 있으니 거기서 그래도 찾기 쉬우라고)
                            - from : 매개변수 1개를 받아서 인스턴스를 리턴하는 경우
                            - of,valueOf : 매개변수 여러개를 받아서 인스턴스를 만들어 리턴하는 경우 
                            - valueOf : of, from보다 더 자세하게 매개변수를 받는다.
                            - instance, getInstance : 미리 만들어져있는 인스턴스를 가져오는 경우 (같은 인스턴스임을 보장하지는 않음!)
                            - create , newInstance : 매번 새로운 인스턴스를 생성해 반환하는 경우.(다른 인스턴스를 보장)
                            - getType : getInstance 에서 인스턴스를 가져오는데 다른 클래스에서 팩터리 메서드를 정의 할 때 사용
                            - newType : newInstance에서 인스턴스를 가져오는데 다른 클래스에서 팩터리 메서드를 정의 할 때 사용
                                - BuffredReader br = Files.newBufferedReader(path);
                            - type : getType과 newType의 간결한 버전
                                - List<Product> productLitst = Collections.list(legacyProductList);
                        - 문서화(javadoc)를 통해 메서드를 설명한다. 
                            - javadoc 규약
                                - @param : 매개변수에 대한 설명
                                - @return : 반환값에 대한 설명
                                - @throws : 던지는 예외에 대한 설명
                                - @see : 외부 링크 또는 텍스트를 표시,,다른 필드나 메소드에 대한 모든 참조 링크를 나타내는 경우 사용
                                - /** 주석을 통해 설명해놓고 @see를 사용, 참조함을 알려주는건 클래스명#메서드명 (자기 자신일 경우 #메서드명)  
                            - javadoc 실행 방법
                                - tools > generated javadoc 클릭
                                - 한글 깨짐 방지를 위해 Other command line arguments에 
                                    - encoding UTF-8 charset UTF-8 docencoding UTF-8 > OK
                                    - open generated documentation in browser 체크하면 생성 후 자동으로 열림,, 
                                        - 체크 안해놨으면 해당 파일 경로의 index.html 열기.
            - 정적 팩토리 메서드 완벽 공략
                - 열거 타입(Enum)은 인스턴트가 하나만 만들어짐을 보장한다.
                    - 열거타입(Enum) : 상수 목록을 담을 수 있는 데이터 타입, 필드가 가질 수 있는 특정한 값들을 제한 할 수 있다. >> Type Safety 보장
                        - Type Safety : 허용하지 않는 값을 방어가 됨을 보장 (컴파일러 차원에서 지원하기 때문에)
                        - ENUM은 인스턴스가 하나만 만들어진다.
                            - Enum은 하나의 인스턴스만 만들어짐을 보장하기 때문에 값 비교시 equals보다 ==을 권장
                                - 만약 비교하는 대상이 null인경우, ==을 쓰면 그냥 아니라고 비교가되고 , equals를 쓰면 NPE가 동작하기 때문
                        - 열거 타입의 이름은 관례적으로 파스칼케이스(첫글자 대문자, 이후 카멜) 사용상수의 이름들은 관례적으로 모두 대문자를 사용
                        - Enum 내부적으로 필드나 생성자를 가질 수 있다.
                        - Enum타입의 메서드
                            - valueOf() : 매개값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴 (외부로부터 문자열을 입력받아 열거 객체로 변환 할 때 사용) 
                                - 해당하는열거 객체가 없다면 IllegalArgumentException 발생
                            - values() : 열거 타입의 모든 객체들을 배열로 만들어 리턴
                            - name() : 열거 객체가 갖고있는 문자열을 리턴하는 메소드. 리턴되는 문자열은 열거타입 정의시 사용한 상수 이름과 동일
                            - ordinal() : 전체 열거 객체 중 몇 번째 열거 객체인지 알려주는 메소드,, 배열의 인덱스
                            - Enum을 key로사용하는 맵이나 Enum을 담고있는 Set을 만들어 쓰고싶으면  EnumSet, EnumMap을 사용해서 사용하면 훨씬 빠름
                                - Color.class을 Enum으로 정의 했을 때
                                    - allOf(Color.class) : Enum의 모든 요소를 포함하는 EnumSet 만들 수 있다.
                                    - noneOf(Color.class) : 빈 Color 컬렉션을 갖는 EnumSet을 만들 수 있다.
                                    - contains(Color.RED) : 특정 요소가 EnumSet에 포함되어 있는지 확인 할 수 있다.
                                    - remove(Color.RED) : 특정 요소를 제거 할 수 있다. 
                - 같은 객체가 자주 요청되는 상황이라면 플라이웨이트 패턴을 사용 할 수 있다.
                    - 플라이웨이트 패턴 : 객체를 재사용 하는 방법 중 하나로, 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴
                        - 자주 변하는 속성과 변하지 않는 속성을 분리하고, 재사용하여 메모리 사용을 줄일 수 있다. 조금이라도 줄이기 위해..
                        - 플라이웨이트 패턴을 생성자로 사용하지않고, 정적 팩토리 메서드를 통해 만들 수 있다.
                - 자바 8 부터는 인터페이스가 정적 메서드를 가질 수 없다는 제한이 풀렸기 때문에 인스턴스화 불가능한 동반 클래스를 둘 이유가 별로 없다.
                    - 기본 메서드
                        - default로 선언
                        - 인스턴스를 통해서 메서드를 호출 할 수 있음
                    - 정적 메서드
                        - static으로 선언하는것 (public이 기본이기 때문에 public이 들어가있음)
                        - 구현 타입을 통해서 메서드를 호출 할 수 있음
                    - private static 메서드
                        - java9 이후부터 제공, 하지만 아직도 private 필드는 정의 할 수 없다.
                        - override 불가능, 인터페이스 이름.메소드 이름 방식으로 사용해야함
                - 서비스 제공자 프레임워크를 만드는 근간이 된다. 
                    - 개념이 중요하지, 구현이 중요한게 아니다. (확장 가능한 애플리케이션을 목적으로..)
                    - 서비스 제공자 프레임워크 구성요소 4가지
                        - 서비스 제공자 인터페이스
                            - 확장이 가능한 서비스의 특징을 정의 ,, Service.interface
                        - 서비스 제공자
                            - 서비스 인터페이스를 구현하는 구현체
                        - 서비스 제공자 등록 API
                            - 스프링 기준 AppConfig처럼 서비스를 등록시키도록 도와주는 API 
                        - 서비스 접근 API
                            - 서비스를 가져오도록 해주는 API (의존관계 주입)
                - 서비스 제공자 인터페이스가 없다면 각 구현체를 인스턴스로 만들 때 리플렉션을 사용해야 한다.
                    - 리플렉션이란
                        - JVM의 클래스 로더를 통해 읽어온 클래스 정보(애노테이션, 필드, 메서드 등)를 사용하는 기술
                        - 네이밍 패턴, 필드이름 등등을 가능하게 해줌 >> 편리성 제공 
                - 브리지 디자인 패턴
                    - 서로 영향을 주지 않으면서 개별적인 계층구조로 발전 할 수 있게끔 구체적인것과 추상적인것을 분리해서 그 사이에 다리를 놓는 패턴
                    - 확장을 유연하게 해줌.
                - 의존 객체 주입 프레임워크 (스프링 프레임워크)

  </details>
  
  <details>
  <summary><b>Item2 생성자에 매개변수가 많다면 빌더를 고려하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item3 private 생성자나 열거 타입으로 싱글턴임을 보증하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item4 인스턴스화를 막으려거든 private 생성자를 사용하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item6 불필요한 객체 생성을 피하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item7 다 쓴 객체 참조를 해제하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item8 finalizer와 cleaner 사용을 피하라</b></summary>
  
  </details>
  
  <details>
  <summary><b>Item9 try-finally보다는 try-with-resources를 사용하라</b></summary>
  
  </details>
  
</details> 

<details>
  <summary><b>3장 모든 객체의 공통 메서드</b></summary>
  
</details>
